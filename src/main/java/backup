/**
     * Deletes a record by key.
     */
    public boolean delete(String key) throws IOException {
        int blockIndex = this.getTargetBlock(key);
        LHBlock<T> primaryBlock = this.readPrimaryBlock(blockIndex);

        boolean deleted = primaryBlock.deleteRecord(this.createPattern(key));

        if (deleted) {
            this.writeBlock(blockIndex, primaryBlock);
            this.totalRecords--;
            this.metadataChanged = true;
        } else {
            int firstOverflow = primaryBlock.getNextOverflow();
            if (firstOverflow != -1) {
                int[] overflowHolder = new int[]{firstOverflow};
                deleted = this.overflowFile.deleteFromChain(overflowHolder, key);

                if (deleted) {
                    primaryBlock.setNextOverflow(overflowHolder[0]);
                    primaryBlock.setOverflowRecordCount(Math.max(0, primaryBlock.getOverflowRecordCount() - 1));
                    primaryBlock.setChainLength(this.calculateChainLength(primaryBlock.getNextOverflow()));

                    this.writeBlock(blockIndex, primaryBlock);
                    this.totalRecords--;
                    this.metadataChanged = true;
                }
            }
        }

        if (deleted) {
            //this.compactBlock(blockIndex);
            this.overflowFile.removeBlocksFromTheEnd();
            while (this.primaryBlocksCount() > this.M && this.getLoadFactor() < D_MIN) {
                this.merge();
            }
        }

        return deleted;
    }

    /**
         * Reduces file size when load factor is too low.
         */
        private void merge() throws IOException {
            int sourceBlockIndex, targetBlockIndex;

            if (this.splitPointer == 0) {
                sourceBlockIndex = this.M * (int) Math.pow(2, this.level) - 1;
                targetBlockIndex = this.M * (int) Math.pow(2, this.level - 1) - 1;
            } else {
                sourceBlockIndex = this.splitPointer + this.M * (int) Math.pow(2, this.level) - 1;
                targetBlockIndex = this.splitPointer - 1;
            }

            // move all records
            this.moveRecords(sourceBlockIndex, targetBlockIndex);

            LHBlock<T> sourceBlock = this.readPrimaryBlock(sourceBlockIndex);
            sourceBlock.clearRecords();
            sourceBlock.setNextOverflow(-1);
            sourceBlock.setOverflowRecordCount(0);
            sourceBlock.setChainLength(0);
            this.writeBlock(sourceBlockIndex, sourceBlock);

            if (this.splitPointer == 0) this.level--;
            this.splitPointer = targetBlockIndex;
            this.metadataChanged = true;

            this.removeEmptyBlocksFromEnd();
            this.overflowFile.removeBlocksFromTheEnd();
        }

        /**
         * Tries to free as many blocks as possible
         */

    // LinearHashing.java
        private void compactBlock(int primaryIndex) throws IOException {
            // 1) Načítaj primárny blok
            LHBlock<T> primary = readPrimaryBlock(primaryIndex);

            // Ak nemá overflow reťazec, nie je čo kompaktnúť
            int firstOverflow = primary.getNextOverflow();
            if (firstOverflow == -1) {
                return;
            }

            // 2) Nazbieraj všetky záznamy z primáru + overflow reťazca
            List<T> allRecords = new ArrayList<>();
            allRecords.addAll(primary.getRecords());

            List<T> overflowRecords = overflowFile.collectAllFromChain(firstOverflow);
            allRecords.addAll(overflowRecords);

            // 3) Fyzicky vyčisti pôvodný overflow chain
            overflowFile.clearChain(firstOverflow);

            // 4) Resetuj primárny blok
            primary.clearRecords();
            primary.setNextOverflow(-1);
            primary.setOverflowRecordCount(0);
            primary.setChainLength(0);

            // 5) --- DEDUP bez Map/Set (spracuj každý key najviac raz) ---
            List<T> uniqueRecords = new ArrayList<>();
            for (int i = 0; i < allRecords.size(); i++) {
                T r = allRecords.get(i);
                String k = r.getKey();
                boolean seen = false;
                for (int j = 0; j < uniqueRecords.size(); j++) {
                    if (uniqueRecords.get(j).getKey().equals(k)) {
                        seen = true;
                        break;
                    }
                }
                if (!seen) {
                    uniqueRecords.add(r);
                }
            }

            // 6) Reinsert unikátov: najprv do primáru, potom do overflow
            for (int i = 0; i < uniqueRecords.size(); i++) {
                T record = uniqueRecords.get(i);

                // Skús uložiť do primárneho bloku
                if (primary.addRecord(record) == -1) {
                    // Primár plný -> vlož do overflow reťazca
                    int currentOverflow = primary.getNextOverflow();
                    int newOverflow = overflowFile.addToChain(currentOverflow, record);

                    // Ak doteraz neexistoval overflow head a teraz vznikol, nastav ho
                    if (currentOverflow == -1 && newOverflow != -1) {
                        primary.setNextOverflow(newOverflow);
                    }
                    // Štatistiku overflow záznamov zvyšuj len pri úspešnom vložení
                    if (newOverflow != -1) {
                        primary.setOverflowRecordCount(primary.getOverflowRecordCount() + 1);
                    }
                }
            }

            // 7) Prepočítaj dĺžku reťazca raz na konci (menej operácií)
            primary.setChainLength(calculateChainLength(primary.getNextOverflow()));

            // 8) Ulož zmenený primárny blok
            writeBlock(primaryIndex, primary);
        }

        /**
         * Moves all records from source block to target block.
         */

    // LinearHashing.java
        private void moveRecords(int sourceIndex, int targetIndex) throws IOException {
            LHBlock<T> sourceBlock = this.readPrimaryBlock(sourceIndex);
            LHBlock<T> targetBlock = this.readPrimaryBlock(targetIndex);

            // 1) nazbieraj všetko zo zdroja (primár + overflow)
            List<T> sourceRecords = new ArrayList<>(sourceBlock.getRecords());
            int firstOverflow = sourceBlock.getNextOverflow();
            if (firstOverflow != -1) {
                sourceRecords.addAll(this.overflowFile.collectAllFromChain(firstOverflow));
                this.overflowFile.clearChain(firstOverflow);
            }

            // 2) vyčisti zdroj
            sourceBlock.clearRecords();
            sourceBlock.setNextOverflow(-1);
            sourceBlock.setOverflowRecordCount(0);
            sourceBlock.setChainLength(0);
            this.writeBlock(sourceIndex, sourceBlock);

            // 3) --- spracuj každý key max. raz (bez Map/Set) ---
            List<T> uniqueRecords = new ArrayList<>();
            for (int i = 0; i < sourceRecords.size(); i++) {
                T r = sourceRecords.get(i);
                String k = r.getKey();
                boolean seen = false;
                for (int j = 0; j < uniqueRecords.size(); j++) {
                    if (uniqueRecords.get(j).getKey().equals(k)) {
                        seen = true;
                        break;
                    }
                }
                if (!seen) uniqueRecords.add(r);
            }

            // 4) presuň unikáty do cieľa (primár → overflow ak treba)
            for (int i = 0; i < uniqueRecords.size(); i++) {
                T record = uniqueRecords.get(i);
                if (targetBlock.addRecord(record) == -1) {
                    int fo = targetBlock.getNextOverflow();
                    int nf = this.overflowFile.addToChain(fo, record);
                    if (fo == -1 && nf != -1) {
                        targetBlock.setNextOverflow(nf);
                    }
                    if (nf != -1) {
                        targetBlock.setChainLength(this.calculateChainLength(targetBlock.getNextOverflow()));
                        targetBlock.setOverflowRecordCount(targetBlock.getOverflowRecordCount() + 1);
                    }
                }
            }

            // 5) zapíš cieľ
            this.writeBlock(targetIndex, targetBlock);
        }